<?php

use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;

/**
 * Ensures timerange field and displays are correctly configured.
 *
 * This helper function is idempotent and safe to run multiple times. It
 * handles the creation and updating of the 'field_appointment_timerange'
 * field, its storage, and its displays, correctly switching between 'daterange'
 * and 'smartdate' field types based on whether the Smart Date module is
 * enabled.
 */
function _appointment_facilitator_ensure_timerange_and_displays() {
  $smart_date_enabled = \Drupal::moduleHandler()->moduleExists('smart_date');
  $field_storage_name = 'field_appointment_timerange';
  $entity_type = 'node';
  $bundle = 'appointment';
  $target_type = $smart_date_enabled ? 'smartdate' : 'daterange';

  // === 1. Field Storage ===
  $storage = FieldStorageConfig::loadByName($entity_type, $field_storage_name);

  if ($storage) {
    // Storage exists, check if it needs to be updated.
    $needs_save = FALSE;

    // Update field type if it doesn't match the target type.
    if ($storage->getType() !== $target_type) {
      $storage->set('type', $target_type);
      $needs_save = TRUE;
    }

    // Update settings based on whether Smart Date is enabled.
    $settings = $storage->getSettings();
    $original_settings = $settings;

    if ($smart_date_enabled) {
      $settings['end_field'] = TRUE;
      if (!isset($settings['default_duration'])) {
        $settings['default_duration'] = 60;
      }
      if (!isset($settings['default_duration_increments'])) {
        $settings['default_duration_increments'] = '15,30,45,60,90,120';
      }
    }
    else {
      // If smart_date is disabled, remove its specific settings.
      unset($settings['default_duration'], $settings['default_duration_increments']);
    }

    if ($settings !== $original_settings) {
      $storage->setSettings($settings);
      $needs_save = TRUE;
    }

    if ($needs_save) {
      $storage->save();
    }
  }
  else {
    // Storage does not exist, create it.
    $settings = ['end_field' => TRUE];
    if ($smart_date_enabled) {
      $settings['default_duration'] = 60;
      $settings['default_duration_increments'] = '15,30,45,60,90,120';
    }
    FieldStorageConfig::create([
      'field_name' => $field_storage_name,
      'entity_type' => $entity_type,
      'type' => $target_type,
      'settings' => $settings,
      'cardinality' => 1,
    ])->save();
  }

  // === 2. Field Instance ===
  if (!FieldConfig::loadByName($entity_type, $bundle, $field_storage_name)) {
    FieldConfig::create([
      'field_name' => $field_storage_name,
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'label' => 'Appointment Time (Range)',
      'settings' => [],
    ])->save();
  }

  $em = \Drupal::entityTypeManager();

  // === 3. Form Display ===
  if ($fd = $em->getStorage('entity_form_display')->load('node.appointment.default')) {
    $target_widget = $smart_date_enabled ? 'smartdate_inline' : 'daterange_default';
    $component = $fd->getComponent($field_storage_name);
    $needs_save = FALSE;

    // Check if the component needs to be updated due to wrong type.
    if (!$component || $component['type'] !== $target_widget) {
      $needs_save = TRUE;
    }

    $new_settings = $component['settings'] ?? [];
    $original_settings = $new_settings;

    if ($smart_date_enabled) {
      $smart_date_widget_defaults = [
        'default_duration' => 60,
        'default_duration_increments' => '15,30,45,60,90,120',
      ];
      // Forcefully apply defaults if they are missing or null. This is more
      // robust than the array union operator, which doesn't handle nulls.
      foreach ($smart_date_widget_defaults as $key => $value) {
        if (!isset($new_settings[$key])) {
          $new_settings[$key] = $value;
        }
      }
    }

    // Check if the component needs to be updated due to changed settings.
    if ($new_settings !== $original_settings) {
      $needs_save = TRUE;
    }

    if ($needs_save) {
      $new_component = [
        'type' => $target_widget,
        'weight' => $component['weight'] ?? -10,
        'region' => $component['region'] ?? 'content',
        'settings' => $new_settings,
      ];
      $fd->setComponent($field_storage_name, $new_component)->save();
    }
  }

  // === 4. View Display ===
  if ($vd = $em->getStorage('entity_view_display')->load('node.appointment.default')) {
    $target_formatter = $smart_date_enabled ? 'smartdate_default' : 'daterange_default';
    $component = $vd->getComponent($field_storage_name);
    // Only update if component is missing or has the wrong type.
    if (!$component || $component['type'] !== $target_formatter) {
      $new_component = [
        'type' => $target_formatter,
        'label' => $component['label'] ?? 'above',
        'weight' => $component['weight'] ?? -10,
        'settings' => $component['settings'] ?? ($target_formatter === 'smartdate_default' ? [
          'format_type' => 'medium',
          'separator' => '-',
          'display_all_day' => FALSE,
        ] : []),
      ];
      $vd->setComponent($field_storage_name, $new_component)->save();
    }
  }
}


/**
 * Create/attach capacity fields in a safe, idempotent way.
 */
function appointment_facilitator_ensure_fields(string $badges_vid, ?string $profile_bundle = NULL): void {
  // Appointment fields (content type: appointment).
  if (!FieldStorageConfig::loadByName('node', 'field_appointment_attendees')) {
    FieldStorageConfig::create([
      'field_name' => 'field_appointment_attendees',
      'entity_type' => 'node',
      'type' => 'entity_reference',
      'settings' => ['target_type' => 'user'],
      'cardinality' => -1,
    ])->save();
  }
  if (!FieldConfig::loadByName('node', 'appointment', 'field_appointment_attendees')) {
    FieldConfig::create([
      'field_name' => 'field_appointment_attendees',
      'entity_type' => 'node',
      'bundle' => 'appointment',
      'label' => 'Attendees',
      'settings' => ['handler' => 'default'],
    ])->save();
  }

  // Badge capacity on taxonomy terms (Badges vocabulary).
  if ($badges_vid && \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($badges_vid)) {
    if (!FieldStorageConfig::loadByName('taxonomy_term', 'field_badge_capacity')) {
      FieldStorageConfig::create([
        'field_name' => 'field_badge_capacity',
        'entity_type' => 'taxonomy_term',
        'type' => 'integer',
        'settings' => ['min' => 1],
        'cardinality' => 1,
      ])->save();
    }
    if (!FieldConfig::loadByName('taxonomy_term', $badges_vid, 'field_badge_capacity')) {
      FieldConfig::create([
        'field_name' => 'field_badge_capacity',
        'entity_type' => 'taxonomy_term',
        'bundle' => $badges_vid,
        'label' => 'Badge Max Attendees',
      ])->save();
    }
  }

  // Facilitator capacity on Profile (bundle configurable).
  if ($profile_bundle && \Drupal::moduleHandler()->moduleExists('profile')) {
    $ptype = \Drupal::entityTypeManager()->getStorage('profile_type')->load($profile_bundle);
    if ($ptype) {
      if (!FieldStorageConfig::loadByName('profile', 'field_coordinator_capacity')) {
        FieldStorageConfig::create([
          'field_name' => 'field_coordinator_capacity',
          'entity_type' => 'profile',
          'type' => 'integer',
          'settings' => ['min' => 1],
          'cardinality' => 1,
        ])->save();
      }
      if (!FieldConfig::loadByName('profile', $profile_bundle, 'field_coordinator_capacity')) {
        FieldConfig::create([
          'field_name' => 'field_coordinator_capacity',
          'entity_type' => 'profile',
          'bundle' => $profile_bundle,
          'label' => 'Max Attendees Per Appointment',
        ])->save();
      }
    }
  }
}

/**
 * Ensure form & view displays surface our fields (idempotent).
 */
function appointment_facilitator_ensure_displays(?string $badges_vid = 'badges', ?string $profile_bundle = 'coordinator'): void {
  $em = \Drupal::entityTypeManager();

  // Form display for node.appointment.
  if ($fd = $em->getStorage('entity_form_display')->load('node.appointment.default')) {
    if ($fd->getComponent('field_appointment_attendees') === NULL) {
      $fd->setComponent('field_appointment_attendees', ['type' => 'entity_reference_autocomplete', 'weight' => -8, 'region' => 'content']);
    }
    // Remove the old capacity field if it exists on the display.
    if ($fd->getComponent('field_appointment_capacity') !== NULL) {
      $fd->removeComponent('field_appointment_capacity');
    }
    $fd->save();
  }

  // View display for node.appointment.
  if ($vd = $em->getStorage('entity_view_display')->load('node.appointment.default')) {
    if ($vd->getComponent('field_appointment_attendees') === NULL) {
      $vd->setComponent('field_appointment_attendees', ['type' => 'entity_reference_label', 'label' => 'above', 'weight' => -8, 'settings' => ['link' => TRUE]]);
    }
    // Remove the old capacity field if it exists on the display.
    if ($vd->getComponent('field_appointment_capacity') !== NULL) {
      $vd->removeComponent('field_appointment_capacity');
    }
    $vd->save();
  }

  // Form display for badge capacity.
  if ($badges_vid && $em->getStorage('entity_form_display')->load('taxonomy_term.' . $badges_vid . '.default')) {
    $fd_badge = $em->getStorage('entity_form_display')->load('taxonomy_term.' . $badges_vid . '.default');
    if ($fd_badge->getComponent('field_badge_capacity') === NULL) {
      $fd_badge->setComponent('field_badge_capacity', ['type' => 'number', 'weight' => 10, 'region' => 'content']);
      $fd_badge->save();
    }
  }

  // Form display for profile capacity.
  if ($profile_bundle && \Drupal::moduleHandler()->moduleExists('profile') && $em->getStorage('entity_form_display')->load('profile.' . $profile_bundle . '.default')) {
    $fd_profile = $em->getStorage('entity_form_display')->load('profile.' . $profile_bundle . '.default');
    if ($fd_profile->getComponent('field_coordinator_capacity') === NULL) {
      $fd_profile->setComponent('field_coordinator_capacity', ['type' => 'number', 'weight' => 10, 'region' => 'content']);
      $fd_profile->save();
    }
  }
}

/**
 * Implements hook_install().
 */
function appointment_facilitator_install() {
  $conf = \Drupal::configFactory()->getEditable('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  _appointment_facilitator_ensure_timerange_and_displays();
  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: ensure fields & displays even on existing sites.
 */
function appointment_facilitator_update_9007() {
  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: Remove the per-appointment capacity field.
 */
function appointment_facilitator_update_9008() {
  $field_storage = FieldStorageConfig::loadByName('node', 'field_appointment_capacity');
  if ($field_storage) {
    $field_storage->delete();
  }

  $field = FieldConfig::loadByName('node', 'appointment', 'field_appointment_capacity');
  if ($field) {
    $field->delete();
  }
}

/**
 * Implements hook_requirements().
 */
function appointment_facilitator_requirements($phase) {
  $requirements = [];
  if ($phase !== 'runtime') {
    return $requirements;
  }

  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  // Check appointment fields.
  $need = [];
  foreach (['field_appointment_timerange', 'field_appointment_attendees'] as $fname) {
    if (!\Drupal\field\Entity\FieldConfig::loadByName('node', 'appointment', $fname)) {
      $need[] = $fname;
    }
  }
  if ($need) {
    $requirements['appointment_facilitator_appointment_fields'] = [
      'title' => t('Appointment Facilitator: Appointment fields'),
      'value' => t('Missing fields: @list', ['@list' => implode(', ', $need)]),
      'severity' => REQUIREMENT_WARNING,
    ];
  }

  // Check badges capacity field.
  $has_badges = (bool) \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($badges);
  if ($has_badges && !\Drupal\field\Entity\FieldConfig::loadByName('taxonomy_term', $badges, 'field_badge_capacity')) {
    $requirements['appointment_facilitator_badge_field'] = [
      'title' => t('Appointment Facilitator: Badge capacity'),
      'value' => t('The vocabulary "@vid" is missing field_badge_capacity.', ['@vid' => $badges]),
      'severity' => REQUIREMENT_WARNING,
    ];
  }

  // Check facilitator profile capacity field if profile module exists.
  if (\Drupal::moduleHandler()->moduleExists('profile')) {
    $ptype = \Drupal::entityTypeManager()->getStorage('profile_type')->load($bundle);
    if ($ptype && !\Drupal\field\Entity\FieldConfig::loadByName('profile', $bundle, 'field_coordinator_capacity')) {
      $requirements['appointment_facilitator_profile_field'] = [
        'title' => t('Appointment Facilitator: Facilitator capacity'),
        'value' => t('The profile bundle "@bundle" is missing field_coordinator_capacity.', ['@bundle' => $bundle]),
        'severity' => REQUIREMENT_WARNING,
    ];
    }
  }

  return $requirements;
}

/**
 * Update: Re-ensure fields & displays to fix any prior issues.
 */
function appointment_facilitator_update_9009() {
  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: Ensure timerange field and displays are correctly configured.
 */
function appointment_facilitator_update_9010() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Re-ensure timerange field and displays are correctly configured.
 */
function appointment_facilitator_update_9011() {
  _appointment_facilitator_ensure_timerange_and_displays();
}
